}
}
resu = NA
resu
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,7,11)){
for(et in c(0.1,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 100, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
rmse_result
dep_result
et_result
x_name
x_name = c(x_name,"green_rating")
x_name
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,7,11)){
for(et in c(0.1,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 100, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
c(x_name,dep_result,et_result,rmse_result)
x_name
paste(x_name,"+")
paste(x_name,sep = "+")
paste("1st", "2nd", "3rd", sep = ", ")
class(x_name)
x_name[1]
x_name[2]
paste(x_name, collapse = '')
paste(x_name, collapse = '+')
c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result)
evaluate_xgb=function(original_data,x_name,y_name){
x_name = c(x_name,"green_rating")
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,7,11)){
for(et in c(0.1,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 100, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
evaluate_xgb(original_data,x_name,y_name)
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# > colnames(original_data)
# [1] "CS_PropertyID"     "cluster"           "size"              "empl_gr"
# [5] "Rent"              "leasing_rate"      "stories"           "age"
# [9] "renovated"         "class_a"           "class_b"           "LEED"
# [13] "Energystar"        "green_rating"      "net"               "amenities"
# [17] "cd_total_07"       "hd_total07"        "total_dd_07"       "Precipitation"
# [21] "Gas_Costs"         "Electricity_Costs" "City_Market_Rent"
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Xgboost is used to model
library(xgboost)
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
## Test for xgboost
## max.depth=2,eta=1,nrounds=2
## Function for evaluation:
evaluate_xgb=function(original_data,x_name,y_name){
x_name = c(x_name,"green_rating")
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,7,11)){
for(et in c(0.1,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 100, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
result = evaluate_xgb(original_data,x_name,y_name)
result
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# > colnames(original_data)
# [1] "CS_PropertyID"     "cluster"           "size"              "empl_gr"
# [5] "Rent"              "leasing_rate"      "stories"           "age"
# [9] "renovated"         "class_a"           "class_b"           "LEED"
# [13] "Energystar"        "green_rating"      "net"               "amenities"
# [17] "cd_total_07"       "hd_total07"        "total_dd_07"       "Precipitation"
# [21] "Gas_Costs"         "Electricity_Costs" "City_Market_Rent"
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Xgboost is used to model
library(xgboost)
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
## Test for xgboost
## max.depth=2,eta=1,nrounds=2
## Function for evaluation:
evaluate_xgb=function(original_data,x_name,y_name){
x_name = c(x_name,"green_rating")
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,7,11)){
for(et in c(0.1,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 20, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
result = evaluate_xgb(original_data,x_name,y_name)
"7.4008012"
result
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# > colnames(original_data)
# [1] "CS_PropertyID"     "cluster"           "size"              "empl_gr"
# [5] "Rent"              "leasing_rate"      "stories"           "age"
# [9] "renovated"         "class_a"           "class_b"           "LEED"
# [13] "Energystar"        "green_rating"      "net"               "amenities"
# [17] "cd_total_07"       "hd_total07"        "total_dd_07"       "Precipitation"
# [21] "Gas_Costs"         "Electricity_Costs" "City_Market_Rent"
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Xgboost is used to model
library(xgboost)
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
## Test for xgboost
## max.depth=2,eta=1,nrounds=2
## Function for evaluation:
evaluate_xgb=function(original_data,x_name,y_name){
x_name = c(x_name,"green_rating")
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,7,11)){
for(et in c(0.1,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
result = evaluate_xgb(original_data,x_name,y_name)
result
x_name_total
x_name_total
result
result
x_name_total
original_data
original_data$green_rating
x_name
x_name = ""
name = x_name_total[12]
name
name
err = evaluate_xgb(original_data,name,y_name)
err
err[4]
as.numeric(err[4])
result = evaluate_xgb(original_data,name,y_name)
as.numeric(result[4])
rmse_record = Inf
for (name in x_name_total){
result = evaluate_xgb(original_data,name,y_name)
if (as.numeric(result[4])<rmse_record){
rmse_record = as.numeric(result[4])
result_record = result
}
}
for (name in x_name_total){
result = evaluate_xgb(original_data,name,y_name)
if (as.numeric(result[4])<rmse_record){
print(result)
rmse_record = as.numeric(result[4])
result_record = result
}
}
q
for (name in x_name_total){
result = evaluate_xgb(original_data,name,y_name)
if (as.numeric(result[4])<rmse_record){
print(result)
rmse_record = as.numeric(result[4])
result_record = result
}
}
y_name = "price"
count = 0
rmse_record = Inf
best_name = ""
best_test_str = ""
best_record_previous = Inf
result_collect = c()
rmse_record = Inf
result_record = c()
y_name = c("revenue_per_square")
rmse_record = Inf
result_record = c()
x_name = c()
for (name in x_name_total){
result = evaluate_xgb(original_data,name,y_name)
if (as.numeric(result[4])<rmse_record){
print(result)
rmse_record = as.numeric(result[4])
result_record = result
}
}
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# > colnames(original_data)
# [1] "CS_PropertyID"     "cluster"           "size"              "empl_gr"
# [5] "Rent"              "leasing_rate"      "stories"           "age"
# [9] "renovated"         "class_a"           "class_b"           "LEED"
# [13] "Energystar"        "green_rating"      "net"               "amenities"
# [17] "cd_total_07"       "hd_total07"        "total_dd_07"       "Precipitation"
# [21] "Gas_Costs"         "Electricity_Costs" "City_Market_Rent"
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Xgboost is used to model
library(xgboost)
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
## Function for evaluation:
evaluate_xgb=function(original_data,x_name,y_name){
x_name = c(x_name,"green_rating")
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,7,11)){
for(et in c(0.1,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
result = evaluate_xgb(original_data,x_name,y_name)
result
?xgb.train
result
x_name
result = evaluate_xgb(original_data,x_name_total,y_name)
result
x_name_total
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
X
Y
colnams(Y)
colnames(Y)
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
print(importance_matrix)
xgb.plot.importance(importance_matrix = importance_matrix)
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
