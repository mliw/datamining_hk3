library(tidyverse)
library(foreign)
options("RStata.StataVersion" = 16)
options("RStata.StataPath" = "\"C:\\Program Files\\Stata16\\StataIC-64\"")
stata("q1_a.do",data.in = NULL,data.out = FALSE)
source('~/.active-rstudio-document', echo=TRUE)
library(BSgenome)
library(Biostrings)
BiocManager::install("BSgenome")
library(BSgenome)
browseVignettes("BSgenome")
library(BSgenome.Celegans.UCSC.ce2
)
?available.genomes
available.genomes()
installed.genomes("BSgenome.Ecoli.NCBI.20080805"       )
installed.genomes("BSgenome.Ecoli.NCBI.20080805"       ,FALSE)
installed.genomes("BSgenome.Ecoli.NCBI.20080805"       ,splitNameParts =  FALSE)
installed.genomes("BSgenome.Ecoli.NCBI.20080805"       ,splitNameParts =  TRUE)
available.genomes()
installed.genomes()
getBSgenome("BSgenome.Ecoli.NCBI.20080805"  )
install("BSgenome.Ecoli.NCBI.20080805")
library(BiocManager)
install("BSgenome.Ecoli.NCBI.20080805")
installed.genomes()
getBSgenome("BSgenome.Ecoli.NCBI.20080805")
xx=getBSgenome("BSgenome.Ecoli.NCBI.20080805")
dim(xx)
xx
xx@single_sequences
str(xx)
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
setwd("G:/UT-Austin2020-2021研究生一年级/ECO395M_DATA MININGSTAT LEARNING/homeworks/datamining_hk3")
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
View(importance_matrix)
importance_matrix$Feature
importance_matrix$Feature[1:10]
importance_matrix$Feature[1:1]
dim(importance_matrix)
dim(importance_matrix)[1]
for i in (1:dim(importance_matrix)[1]){
tem_features = importance_matrix$Feature[1:i]
print(tem_features)
}
for (i in 1:dim(importance_matrix)[1]){
tem_features = importance_matrix$Feature[1:i]
print(tem_features)
}
tem_features
i = 3
tem_features = importance_matrix$Feature[1:i]
print(tem_features)
union(tem_features,c("green_rating"))
for (i in 1:dim(importance_matrix)[1]){
tem_features = importance_matrix$Feature[1:i]
tem_features = union(tem_features,c("green_rating"))
print(i)
print(tem_features)
}
y_name
y_name
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("green_rating","revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
## Function for evaluation:
evaluate_xgb=function(original_data,x_name,y_name){
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,5,7,9,11)){
for(et in c(0.1,0.25,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
result = evaluate_xgb(original_data,x_name_total,y_name)
for (i in 1:dim(importance_matrix)[1]){
tem_features = importance_matrix$Feature[1:i]
tem_features = union(tem_features,c("green_rating"))
print(i)
print(tem_features)
# evaluate_xgb=function(original_data,x_name,y_name)
}
result
x_name_total
x_name_total
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
## Function for evaluation:
evaluate_xgb=function(original_data,x_name,y_name){
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,5,7,9,11)){
for(et in c(0.1,0.25,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
result = evaluate_xgb(original_data,x_name_total,y_name)
for (i in 1:dim(importance_matrix)[1]){
tem_features = importance_matrix$Feature[1:i]
tem_features = union(tem_features,c("green_rating"))
print(i)
print(tem_features)
# evaluate_xgb=function(original_data,x_name,y_name)
}
x_name_total
x_name_total
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
X = as.matrix(original_data[c(x_name_total,"green_rating")])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
result
x_name_total
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total)])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total)])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
## Function for evaluation:
evaluate_xgb=function(original_data,x_name,y_name){
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,5,7,9,11)){
for(et in c(0.1,0.25,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
i = 3
tem_features = importance_matrix$Feature[1:i]
tem_features = union(tem_features,c("green_rating"))
print(i)
print(tem_features)
result = evaluate_xgb(original_data,tem_features,y_name)
result
result_collect = c()
for (i in 1:dim(importance_matrix)[1]){
tem_features = importance_matrix$Feature[1:i]
tem_features = union(tem_features,c("green_rating"))
result = evaluate_xgb(original_data,tem_features,y_name)
result_collect = rbind(result_collect,result)
print(i)
}
result_collect
result_collect = data.frame(result_collect)
result_collect
View(result_collect)
View(result_collect)
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total)])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
## Function for evaluation:
evaluate_xgb=function(original_data,x_name,y_name){
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,5,7,9,11)){
for(et in c(0.1,0.25,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
result_collect = c()
for (i in 1:dim(importance_matrix)[1]){
tem_features = importance_matrix$Feature[1:i]
tem_features = union(tem_features,c("green_rating"))
result = evaluate_xgb(original_data,tem_features,y_name)
result_collect = rbind(result_collect,result)
print(i)
}
result_collect = data.frame(result_collect)
View(result_collect)
View(importance_matrix)
colnames(result_collect) = c("features","max_depth","eta(learning rate)","cv-rmse")
View(result_collect)
write.csv(result_collect,"data/result_collect.csv")
result_collect
paste(1:9,"feature")
paste("top",1:9,"feature")
paste("top",1:9,"features")
result_collect$features = paste("top",1:dim(result_collect)[1],"features")
result_collect
write.csv(result_collect,"data/result_collect.csv")
write.csv(result_collect,"data/result_collect.csv")
# \section{Predictive model building: green certification}
### Load the data
library(ggplot2)
library(xgboost)
library(tidyverse)
original_data = read.csv("data/greenbuildings.csv")
original_data$revenue_per_square = (original_data$leasing_rate/100)*original_data$Rent
# Your goal is to build the best predictive model possible for revenue per square
# foot per calendar year, and to use this model to quantify the average change in
# rental income per square foot (whether in absolute or percentage terms) associated
# with green certification, holding other features of the building constant.
# We have 2 goals
# (1) build the best predictive model possible for revenue per square
# foot per calendar year
# Remove features not nacessary
# CS_PropertyID is just ID leasing_rate and rent information leakage
total_name = colnames(original_data)
valid_name = setdiff(total_name,c("CS_PropertyID","leasing_rate","Rent","Energystar","LEED"))
# green_rating must be included in the features.
x_name_total = setdiff(valid_name,c("revenue_per_square"))
y_name = c("revenue_per_square")
### Feature Importance:
X = as.matrix(original_data[c(x_name_total)])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
bst = xgb.train(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2,
max_depth = 7 , eta = 0.5, objective = "reg:squarederror")
importance_matrix = xgb.importance(model = bst)
xgb.plot.importance(importance_matrix = importance_matrix)
## Function for evaluation:
evaluate_xgb=function(original_data,x_name,y_name){
rmse_result = Inf
dep_result = NA
et_result = NA
X = as.matrix(original_data[x_name])
Y = as.matrix(original_data[y_name])
dtrain = xgb.DMatrix(X, label = Y)
for (dep in c(3,5,7,9,11)){
for(et in c(0.1,0.25,0.5)){
set.seed(100)
cv = xgb.cv(data = dtrain, verbose = FALSE,nrounds = 50, nthread = 2, nfold = 5, metrics = list("rmse"),
max_depth = dep , eta = et, objective = "reg:squarederror")
evaluation_matrix = cv[["evaluation_log"]]
test_rmse_mean = as.numeric(evaluation_matrix[dim(evaluation_matrix)[1],"test_rmse_mean"])
if (test_rmse_mean<rmse_result){
rmse_result = test_rmse_mean
dep_result = dep
et_result = et
}
}
}
return(c(paste(x_name, collapse = '+'),dep_result,et_result,rmse_result))
}
# result_collect = c()
# for (i in 1:dim(importance_matrix)[1]){
#   tem_features = importance_matrix$Feature[1:i]
#   tem_features = union(tem_features,c("green_rating"))
#   result = evaluate_xgb(original_data,tem_features,y_name)
#   result_collect = rbind(result_collect,result)
#   print(i)
# }
# result_collect = data.frame(result_collect)
# colnames(result_collect) = c("features","max_depth","eta(learning rate)","cv-rmse")
# result_collect$features = paste("top",1:dim(result_collect)[1],"features")
# write.csv(result_collect,"data/result_collect.csv")
